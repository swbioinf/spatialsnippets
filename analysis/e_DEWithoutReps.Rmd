---
title: "scRNAseq differential expression without replicates"
author: 
   - "Sarah Williams"
output:
  html_notebook: 
    toc: yes
    code_folding: hide
  html_document:
    toc: yes
    df_print: paged
    code_folding: hide
editor_options:
  chunk_output_type: console
bibliography: /home/s.williams/zotero_export/MyLibrary.bib
---



```{r angrylibrarian, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(echo = TRUE)
```


<!-- keywords
# Not yet used, but add keywords as appriopriate. 

insituspatial
seurat
differntialexpression
test

-->


# Overview


Sometimes there are no biological replicates, yet you still want to make a comparison. While not ideal, its possible. Individual cells may be treated as 'replicates' to explore the difference between two samples.


![](assets/de_1v1.png)


This requires:

* Cell clusters
* 2 or more samples (or grouping to compare)


For example:

* What genes are differentially expressed between the knockout (n=1) and control(n=1), for every cell type.
* In my n=1 pilot study - what is differentially expressed between two of my stromal clusters?


Steps:

1. Filter to testable genes (enough expression to see changes)
2. Test for changes in gene expression
3. Plot DE results and individual genes. 


## Gotchas


**Caveat on 1 vs 1 comparisons!**

Essentially the results we get will be testing the difference between *this* specific sample and *that* specific sample. The p-values for such a test can be very significant!

But those p-values can't be compared to those using multiple samples, and we cannot tell if our results will generalise to other samples. They are likely good candidates for further work though!

**But what about pooled samples? **

Note that 'pooling' multiple unlabelled biological samples before library prep will still count as 'one' replicate no many how many samples are in the pool - because we have no way to tell what sample a cell comes from. A change in gene expression could be from a single outlier sample.

NB: Using cell hashing approaches to tag samples before pooling avoids this issue.




# Worked example 

The data for this example is from paper [Forming nephrons promote nephron progenitor maintenance and branching morphogenesis via paracrine BMP4 signalling under the control of Wnt4](https://www.biorxiv.org/content/10.1101/2023.11.19.567482v1.full) [@moreauFormingNephronsPromote2023a]

This study included 10X chromium single cell RNAseq data from 4 conditions, with 3-4 E14.5 mice pooled per group. 

* Sample1 (Wnt4FloxKO):  Wnt4Flox/Flox Six2-Conditional Wnt4 Knockout
* Sample2 (Wnt4FloxHet):  Wnt4Flox/+ Six2-Conditional Wnt4 Het
* Sample3 (Wnt4Het): Wnt4 GCE/+ Control Wnt4 Het
* Sample4 (Wnt4KO): Wnt4 GCE/GCE Knockout Wnt4

In that paper they explain that complete or conditional homozygous knockout of Wnt4 gene results in abnormal kidney development, and they use scRNAseq data to explore effects at cellular level. [@moreauFormingNephronsPromote2023a]


In this vignette, we will test for differential expression in each cell type for two 1 vs 1 comparisons:

* Wnt4KO vs Wnt4Het : Complete knockout vs heterozgote
* Wnt4FloxKO vs Wnt4FloxHet : Conditional (Flox) knockout vs heterozygote


## Load Libraries and Data

```{r}
library(Seurat)
library(edgeR)
library(limma)
library(DT)
library(tidyverse)


dataset_dir      <- '~/projects/spatialsnippets/datasets'
seurat_file      <- file.path(dataset_dir, 'Wnt4KO_Moreau2023',  "Wnt4KOE14.5_11_ss.rds")

so <- readRDS(seurat_file)
```


## Experimental Design


In this case the sample (sample 1-4), 'genotype' GT effect and GT short columns are just different labels for this same groups.  We will use GTshort as our 'sample' names throughout.

There are between 4000 and 10000 cells per sample. 

```{r}
select(so@meta.data, sample, Genotype, GTeffect, GTshort) %>% 
  as_tibble() %>% 
  group_by( sample, Genotype, GTeffect, GTshort) %>%
  summarise(num_cells=n(), .groups = 'drop') %>%
  DT::datatable()
```


## Filter


### Counts per cell

A minimum-counts-per-cell threshold was already applied to this dataset (during preprocessing) so nothing to do here.


```{r}
# This is plenty
min(so$nCount_RNA)
```


### Cells per group

How many cells are there for each celltype for each sample? If there are too few on either side of the contrast, we won't be able to test. 


How many is too few? 50 might be a good threshold. In this case however, we might 
consider being very permissive and allowing just 20 cells to look at some celltypes that are clearly reduced or increased in number between conditions (e.g. c9,c10,c11). 

They're interesting in this experiment, but have to keep in mind during interpretation that results may be less reliable. 

We will apply that filter later when running the differential expression.

```{r}
min_cells_per_group <- 20 # used later
table(so$CelltypeCode, so$GTshort)
```


## What data/assay/layer do we actually need?


In short - we want to run this differential expression on the normalised data,
and typically that's in the *data* layer of the *RNA* assay.


-----

The longer explaination:

From seurat v5, a Seruat object has mutiple _assays_ (but usually just one, called RNA), each of which has multiple _layers_.

Each _assay_ generally has some or all of the following layers:

* **counts** :  Just the plain old counts matrix.
* **data** : A normalised counts matrix 
* **scale.data** : A normalised and scaled counts matrix, which often only contains a subset of the highly variable genes. (Used for PCA e.t.c)

Depending on how you setup your object, you might have one set of counts/data/scale.data layers per sample. (e.g. counts.sample1, counts.sample2 ...). In that case you'll want to proceed with differential expression on a merged layer - which you can produce with the JoinLayers() function. See how that's used in [seurats v5 integration tutorial](https://satijalab.org/seurat/articles/seurat5_integration#layers-in-the-seurat-v5-object)


Multiple assays come into play more often with multimodal data - a different assay per modality (RNA, ADT, e.t.c). See [multimodal vigette](https://satijalab.org/seurat/articles/multimodal_vignette) for details.


Beware: The notation around Layers and Assays has changed between Seurat v4 and v5! In older seurat objects ‘assay’ is used to refer to v5 layers.

--------

This dataset however is a little different.It was analysed with an earlier version of Seurat, and has ended up with two assays; an RNA and an SCT assay. 
NB: The newer [seurat 5 integration workflow](https://satijalab.org/seurat/articles/seurat5_integration#layers-in-the-seurat-v5-object) behaves differently now, and doesn't make that assay like that.



```{r}
Assays(so)
DefaultAssay(so)
```

Alternatively the seurat summary tells us the assasy, and layers in the default assay
```{r}
so
```

In any case, we want the unintegrated 'RNA' assay for calculating differential expression, not our integrated SCT assay (This is the reccomendation of the Seurat developers, see [discussion](https://github.com/satijalab/seurat/discussions/4032) )
The between sample integration was useful for visualising the cell-cell relationships together (e.g. superimposing samples on a UMAP layout), but for differential expression, we need to look at the variation between samples.



```{r}
DefaultAssay(so) <- 'RNA'
so
```

Update: seem to have counts in rna data, chuck a normalisation on.
```{r}
so <- NormalizeData(so)
```


```{r}
GetAssayData(so, assay = "RNA", layer = "counts")[1:10,1:3]
GetAssayData(so, assay = "RNA", layer = "data")[1:10,1:3]
GetAssayData(so, assay = "SCT", layer = "data")[1:10,1:3]
GetAssayData(so, assay = "SCT", layer = "scale.data")[1:10,1:3]
```







## Run just one differential expression

Lets say we want to test the differnece between samples Wnt4KO and Wnt4Het within Nephron progenitors (NP),


We first need to setup our object for use with the _FindMarkers_ function that runs differential expression.

Though we can specify our layer with the slot parameter, there's no parameter for assay in FindMarkers, you need to make sure your assay is the one you want to use.
```{r}
DefaultAssay(so)
DefaultAssay(so) <- "RNA"
```

Likewise, there's no paremeter to specify which column of the metadata out groups may be found in. We 
instead set Indents()
```{r}
Idents(so) <- so$GTshort
levels(Idents(so))
```

Now make a subset of our seurat object that's just the NP cells.

```{r}
so.np <- subset(so, CelltypeCode == "c3: NP")
table(so$GTshort)
```


Finally - run findmarkers. We will stick with the default method that uses a wilcoxon rank-sum test (but to explore other tests see the (seurat DE vignette)[https://satijalab.org/seurat/articles/de_vignette]). 

```{r}
de_result <- FindMarkers(so.np, 
                         ident.1  = 'Wnt4KO', 
                         ident.2  = 'Wnt4Het',
                         slot     = 'data',   # This is the default
                         test.use = "wilcox",  # This is the default
                         max.cells.per.ident = 40 # subset for speed.
)
```

Check out those p-values! They're so significant because each cell is treated as its own replicate.
```{r}
DT::datatable(de_result[1:100,])
```


Some improvements/changes can be made:

* **This is slow**: Add the *max.cells.per.ident* parameter to subsample down to a specified maximum number of cells per group. It can be useful to set a very low number when testing (e.g 20), then a much higher one (e.g. 500, or no limit at all) for your real run.

* **Adjust filtering**: 
   * By default the results are filtered by a *logfc.threshold* of 0.1. Consider removing this threshold (set it to 0) if you want to get stats for genes that are present but unchanging.
   * *min.cells.pct* by default 0.01, genes with very low expression in both groups will be ignored. You might consider disabling this test if you've already done your onw filtering.


```{r}
de_result <- FindMarkers(so.np, 
                         ident.1  = 'Wnt4KO', 
                         ident.2  = 'Wnt4Het',
                         slot     = 'data',   # This is the default
                         test.use = "wilcox",  # This is the default
                         logfc.threshold = 0, 
                         max.cells.per.ident = 40 # subset for speed.
)
```

Same contrast with fewer cells.

```{r}
DT::datatable(de_result[1:100,])
```


Its quite common practice, especially with so many highly significant genes, to 
filter our results by fold-change. Its important threshold on 'absolute' values,
so we don't accidentally exclude downregulation; like that Wnt4 being downregulated in its knockout!
```{r}
DT::datatable(filter(de_result, abs(avg_log2FC) > 2 ))
```






   
   












## Run differential expression for every cluster

We typically want to know about changes in every cluster. We can simply loop through and run them one-by-one. This can make for a lot of contrasts!

```
2x comparisons * 19x clusters = 38 sets of differential results 
```

The below code makes a big table of all the tests - recording which contrast was being done in which cluster.



NB: Note that the _FindMarkers()_ function returns a table with feature names as a rowname. Rownames are expected to be unique. So while that is fine for one comparison, but when we want to put more together, we need to give it its own column. If we don't, there'll be gene names with '.1' appended to the end!


```{r eval=FALSE}
# Set threhoehsolds
min_cells_per_group <- 20

# Calculate DE across every celltype
# Empty list to collect results
de_result_list     <- list()
de_result_sig_list <- list()

# the contrasts
# If we store them in a list we can give the nice names
contrast_list <-  list( # 'Test'      vs  'control'  
                       FloxWnt4KOvsFloxHet  = c('Wnt4FloxKO',      'Wnt4FloxHet' ) ,
                       TotalWnt4KOvsHet     = c('Wnt4KO',          'Wnt4Het'     ) )

## Or you could autogenerated them
#make_contrast_name <- function(contrast_parts){ paste0(contrast_parts[1],"vs",contrast_parts[1])}
#contrast_names <- sapply(FUN=make_contrast_name, X=contrast_list) 
#names(contrast_list) <- contrast_names


# note keeping all 4 samples before two contrasts. (actually does that matter for wilcox ranK sum - CHECK)

#the_celltype = 'c15: Podocyte'
#the_celltype = "c16: Blood"
#contrast_name <- 'TotalWnt4KOvsHet'
  
for (the_celltype in levels(so$CelltypeCode)[5:7]) {
  
  # Subset to one cell type. 
  print(the_celltype)
  
  so.this <- subset(so, CelltypeCode == the_celltype)
  
  # count how many cells within each sample (GTshort)
  # And list which samples have more than the minimum
  cells_per_sample <- table(so.this$GTshort)
  print(cells_per_sample)
  samples_with_enough_cells <- names(cells_per_sample)[cells_per_sample > min_cells_per_group]
  
  # SUbset to only those samples (might be all cells, might be no cells)
  so.this <- subset(so.this, GTshort %in% samples_with_enough_cells)
  

  # For each listed contrast, do both sides of the contrast have enough cells?
  # This is of course much simpler if you only have one contrast!
  for (contrast_name in names(contrast_list)) {
    
    # from mycontrastname pull out list of the two samples involved;
    # c('test', 'control')
    contrast <- contrast_list[[contrast_name]]
    
    # Only run this contrast if both sides pass!
    if (all(contrast %in% samples_with_enough_cells)) {
      print(contrast_name) 

      # We need to tell Seurat to group by _sample_ not cluster.
      Idents(so.this) <- so.this$GTshort
      
      
      de_result <- FindMarkers(so.this, 
                               ident.1  = contrast[1], 
                               ident.2 = contrast[2],
                               slot     = 'data',
                               test.use = "wilcox", # the default
                               min.pct  = 0.01,   # Note 
                               max.cells.per.ident = 100 # 1000 # if you have really big clusters, set this to subsample!
                               )
  
      
      # It can be helpful to know the average expression of a gene
      # This will give us the average (per cell) within this celltype.
      avg_expression <- rowMeans(GetAssayData(so.this, assay = 'SCT', layer="data"))
      
      
      
      de_result.formatted <- de_result %>%
      rownames_to_column("target") %>%
      mutate(contrast=contrast_name,
             celltype=the_celltype,
             avg_expression=avg_expression[target]) %>%
      select(celltype,contrast,target,avg_expression, everything()) %>%
      arrange(p_val)
  
      # Filter to just significant results, optionally by log2FC.
      de_result.sig <- filter(de_result.formatted, 
                         p_val_adj < 0.01,
                         abs(avg_log2FC) > log2(1.5) )

      # Record these results in a list to combine
      full_name <- paste(contrast_name, the_celltype)
      de_result_list[[full_name]] <- de_result.formatted
      de_result_sig_list[[full_name]] <- de_result.sig
      
    }
  }
}

# Join together results for all celltypes, and pull out those with a singificant adjusted p-value
de_results_all <- bind_rows(de_result_list)
de_results_sig <- bind_rows(de_result_sig_list)


```

Check out the full set of significant DE genes

```{r eval=FALSE}
DT::datatable(de_results_sig)
```

Save the results.

```{r eval=FALSE}
# Save the full set of results as a tab-deliminated text file.
# This is useful for parsing later e.g. for functional enrichment
write_tsv(x = de_results_all, "~/myproject/de_results_all.tsv")

# If you don't have too many contrasts and celltypes, 
# you can save it as an excel file, with each contrast in a seprate tab.
library(writexl)
write_xlsx(de_result_list,      "~/myproject/de_results_all.xlsx")
write_xlsx(de_result_sig_list,  "~/myproject/de_results_sig.xlsx")
```




## Check individual results

Plot some example genes.


Discuss (how to pick stuff thats real)

* further filtering - where small significant changes dominate
* violin plots are hard to read
* MA style plots.










# Code Snippet

Copy and paste this bit into your own script to adapt to your own data. 
Make as generic as possible, just a framework.

```{r eval=FALSE}

# This code does not run

```



# Results

```{r eval=FALSE}
DT::datatable(de_result.sig)
```

* **celltype**: The cluster or celltype the contrat is within. Added by running code.
* **contrast**: The name of what is being compared. Added by running code.
* **target** : Gene name. (NB: Added by our running code, in the direct output of  FindMarkers(), these are row names instead)
* **avg_expression** : Average expression of target within celltype group. (Added by running code)
* **p_val** : P value without multiple hypothesis correction - see *p_val_adj* 
* **avg_log2FC** : Average log 2 fold change of the comparison. Is calculated as: _log2(test expression) - log2(control expression)_ A value of 0 represents no change, +1 is a doubling, and -1 is a halving of expression.
* **pct.1** : Percent of cells in group 1 (generally test) that express the gene at all.
* **pct.2** : Percent of cells in group 2 (generally control/WT/reference) that express the gene at all.
* **p_val_adj** : Pvalue with multiple hypothesis correction. This may be used for filtering.




# More information 

List of useful resources. Papers, vignettes, pertinent forum posts 

* [Wnt4 KO in developing mouse kidney - 10X Chromium scRNAseq](d_Wnt4KO.html): [Forming nephrons promote nephron progenitor maintenance and branching morphogenesis via paracrine BMP4 signalling under the control of Wnt4](https://www.biorxiv.org/content/10.1101/2023.11.19.567482v1.full) [@moreauFormingNephronsPromote2023a] : The paper with this data.



* [Seurat Differential Expression Vignette](https://satijalab.org/seurat/articles/de_vignette) : How to do differential expression with the seurat package. Tells you how to use the multiple statistical tests that seurat offers.
* [OSCA Differntial Expression](https://bioconductor.org/books/3.19/OSCA.multisample/multi-sample-comparisons.html): The excellent book [Orchestrating single cell analysis](https://bioconductor.org/books/release/OSCA/book-contents.html#multi-sample) includes a section on differential expression, it focusses on pseuboulk approaches with replicates (which can't be used for a 1 vs 1) using the bioconductor toolkit, but provides useful background.

* ['The Seurat Object' in scRNAseq analysis with R](https://swbioinf.github.io/scRNAseqInR_Doco/preprocessing.html#the-seurat-object) Small section of this document 'the Seurat object' has some explanation of the seurat object format.



# Refereneces

<!-- nothing here, autopopulated from bibliography: in json -->

