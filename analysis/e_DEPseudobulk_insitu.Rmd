---
title: "Differential expression between groups using pseudobulk"
author: "Sarah Williams"
output:
  html_notebook: 
    toc: yes
    code_folding: hide
  html_document:
    toc: yes
    df_print: paged
    code_folding: hide
editor_options:
  chunk_output_type: console
---

<!-- keywords

insituspatial
seurat
de
test

-->

# Overview

![](assets/insitu_spatial_pseudobulk_de.png)

This requires:

* Biological replicates for each group
* Assigned cell types
* [Optionally] Multiple fovs measured per sample





# Worked example 

How does gene expression change within each cell type between Ulcerative colitis or Crohn's disease, and Healthy controls?

## Load libraries and data

```{r}
library(Seurat)
library(speckle)
library(tidyverse)
library(limma)
library(DT)
library(edgeR)
```

```{r}
data_dir              <- file.path("~/projects/spatialsnippets/datasets/GSE234713_IBDcosmx_GarridoTrigo2023/processed_data") 
seurat_file_01_loaded <- file.path(data_dir, "GSE234713_CosMx_IBD_seurat_01_loaded.RDS")
```


```{r}
so <- readRDS(seurat_file_01_loaded)
```

## Experimental design

<!-- Move this to own page? --->

There are three individuals per condition (one tissue sample from each individual). With multiple fovs on each physical tissue sample.
```{r}
sample_table <- select(as_tibble(so@meta.data), condition, individual_code, fov_name) %>%
  unique() %>% 
  group_by(condition, individual_code) %>% 
  summarise(n_fovs= n(), item = str_c(fov_name, collapse = ", "))

DT::datatable(sample_table)
```






## Count how many cells of each type in your data

Using a pseudobulk approach.

* Need at least x reads in a cell to include it
* Need at least x cells of a celltype within an fov to include that
* Can only test where we have at least 2 samples on each side of a contrast.


```{r}
min_reads_per_cell <- 200

ggplot(so@meta.data, aes(x=nCount_RNA)) +
  geom_density() +
  geom_vline(xintercept = min_reads_per_cell, lty=3) +
  scale_x_log10() +
  theme_bw()+
  ggtitle("How many reads per cell?")


so<- so[,so$nCount_RNA >= min_reads_per_cell]
```



We will pool each celltype within each fov (cluster_group). But there needs to be a certain number of cells for that to work.


Note there are much fewer t-cells overall, but given that we have a high number of samples, there should still be enough to include.  Its typical that some of the less common cell types are difficult or impossible to reliably test.

```{r}
min_cells_per_fovcluster <- 20

so$fov_cluster <- paste0(so$fov_name,"_", so$celltype_subset)

celltype_summary_table <- so@meta.data %>% 
  group_by(condition, group, individual_code, fov_name, celltype_subset, fov_cluster) %>%
  summarise(cells=n(), .groups = 'drop')
DT::datatable(celltype_summary_table)



```


```{r}
ggplot(celltype_summary_table, aes(x=cells, col=celltype_subset)) +
  geom_density() +
  geom_vline(xintercept=min_cells_per_fovcluster, lty=3) +
  geom_rug() +
  scale_x_log10() +
  theme_bw() +
  ggtitle("How many cells per fov-cluster?")
```


```{r}
passed_fov_clusters <- celltype_summary_table$fov_cluster[celltype_summary_table$cells >= min_cells_per_fovcluster]
```

## Calculate pseudobulk


```{r}
pseudobulk_counts <- PseudobulkExpression(so, assays = "RNA", layer="counts",  method = 'aggregate', group.by = 'fov_cluster')
pseudobulk_counts_matrix <- pseudobulk_counts[["RNA"]]

# CHange - back to _. Ideally we'd have neither, but - will cause problems later
colnames(pseudobulk_counts_matrix)<-gsub("-","_",colnames(pseudobulk_counts_matrix))

```

Keep only the passed fovs
```{r}
pseudobulk_counts_matrix <- pseudobulk_counts_matrix[,passed_fov_clusters]

# pull in relevant annotation in a matched order
pseudobulk_anno_table <- celltype_summary_table
match_order <- match(passed_fov_clusters, pseudobulk_anno_table$fov_cluster)
pseudobulk_anno_table <- pseudobulk_anno_table[match_order,]
stopifnot(all(colnames(pseudobulk_counts_matrix) == pseudobulk_anno_table$fov_cluster  ))


```


## Calculate Differential Expression


```{r}
min_samples_to_calc <- 2 # require 2 samples on on either side of contrast

de_result_list <- list()

# celltype_subset is a matrix
for (the_celltype in levels(so$celltype_subset)) {
  
  anno_table.this   <- pseudobulk_anno_table[pseudobulk_anno_table$celltype_subset == the_celltype,]
  count_matrix.this <- pseudobulk_counts_matrix[,anno_table.this$fov_cluster]
 
  print(the_celltype)
  
  # skip clusters with nothing 
  if( nrow(anno_table.this) < 1 ) {next}
  
  # Setup objects for limma
  dge <- DGEList(count_matrix.this)
  dge <- calcNormFactors(dge)
  
  # Build model
  group           <- anno_table.this$group
  individual_code <- anno_table.this$individual_code

  # To do any calculations, we need at least 2 pseudobulk groups per contrast.
  # there are plenty in this experiemnt, but with less replicates and rare cell types
  # it may be neccesary to check and skip certain contrasts

  # Model design 
  design    <- model.matrix( ~0 + group)

  vm  <- voom(dge, design = design, plot = FALSE)
  
  # Adding dupliate correlation to use individual fovs, rather than pooled per biosample
  corrfit <- duplicateCorrelation(vm, design, block=individual_code)
  fit     <- lmFit(vm, design, correlation = corrfit$consensus, block=individual_code) 

  # Then fit contrasts and run ebayes
  contrasts <- makeContrasts(UCvHC  = groupUC - groupHC, 
                             CDvHC  = groupCD - groupHC,
                           levels=coef(fit))

  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit)

  
  for ( the_coef in colnames(contrasts) ) {
    de_result.this <- topTable(fit, n = Inf, adjust.method = "BH", coef = the_coef) %>%
      rownames_to_column("target") %>%
      mutate(contrast=the_coef,
             celltype=the_celltype) %>%
      select(celltype,contrast,target,everything()) %>%
      arrange(P.Value)
    
    
      de_result_list[[paste(the_celltype, the_coef, sep="_")]] <- de_result.this
    
  }

  

 
}
de_results_all <- bind_rows(de_result_list)
de_results_sig <- filter(de_results_all, adj.P.Val < 0.01)
```



Table of significant results.

```{r}
DT::datatable(de_results_sig)
```



## DE plots


```{r}
library(ggrepel) # gg_repel, For non-overlapping gene labels


make_ma_style_plot <- function(res_table, pval_threshold = 0.01, n_genes_to_label = 10) {
  p <- ggplot(res_table, aes(x=AveExpr, y=logFC, col=adj.P.Val < pval_threshold) ) +
    geom_hline(yintercept = c(0), col='grey80') +
    geom_point(pch=3) +
    geom_text_repel(data    = head(arrange(filter(res_table , adj.P.Val < pval_threshold ), P.Value), n=5),
                    mapping = aes(label=target), col="red" ) +
    theme_bw() +
    geom_hline(yintercept = c(-1,1), lty=3) +
    scale_colour_manual(values = c('FALSE'="black", 'TRUE'="red")) +
    theme(legend.position = 'none')
  return(p)
}

```

```{r}
#res_table.UCvHC.epi <- filter(de_results_all, contrast == "UCvHC", celltype=="epi")

make_ma_style_plot(res_table = filter(de_results_all, contrast == "UCvHC", celltype=="epi"))
make_ma_style_plot(res_table = filter(de_results_all, contrast == "UCvHC", celltype=="tcells"))
make_ma_style_plot(res_table = filter(de_results_all, contrast == "UCvHC", celltype=="stroma"))



```

## Check some examples

Its always worth visualising how the expression of your differentially expressed genes really looks, with respect to your experimental design. How best to do this depends on your experiment. 


The results suggests that TNFRSF18 was significantly DE between individuals with Ulcerative Colitis and Healthy Controls in plasma cells. There's some very convenient seurat plots below;

```{r}
VlnPlot(subset(so, celltype_subset == "plasmas"), features = "TNFRSF18", group.by = 'group', alpha = 0.1)
FeaturePlot(so, "TNFRSF18", split.by = "group")
```

But it gets difficult to summarise data at the single cell level. We can also use the the normalised pseudobulk expression to see how gene expression varies within each fov,individual,celltype and condition - The plot below shows an overview of TNFRSF18 across the entire experiment.  

NB: We have to plot normalised expression instead of the raw counts as there are vastly different numbers of cells in each fov+celltype grouping. 

```{r}
# Get tmm normalised coutns for all pseudobulk
# WHen we did the DE we calculated this a celltype at a time, so values might differ slightly!
dge <- DGEList(pseudobulk_counts_matrix)
dge <- calcNormFactors(dge)
norm_pseudobulk <- cpm(dge , log=TRUE) # uses tmm normalisation

# Plot expression for TNFRSF18
plottable <- cbind(pseudobulk_anno_table, expression = norm_pseudobulk["TNFRSF18",])
ggplot(plottable, aes(x=individual_code, y=expression, col=condition )) +
  geom_boxplot(outlier.shape = NA) +
  geom_point() + 
  theme_bw() + 
  theme(axis.text.x=element_text(angle = -90, hjust = 0)) + 
  facet_wrap(~celltype_subset) 

```


And you can compare that with IGHG1, which was flagged at differentially expressed across multiple cell types.

```{r}
plottable <- cbind(pseudobulk_anno_table, expression = norm_pseudobulk["IGHG1",])
ggplot(plottable, aes(x=individual_code, y=expression, col=condition )) +
  geom_boxplot(outlier.shape = NA) +
  geom_point() + 
  theme_bw() + 
  theme(axis.text.x=element_text(angle = -90, hjust = 0)) + 
  facet_wrap(~celltype_subset) 
```

# Code Snippet



```{r eval=FALSE}
library(Seurat)
library(edgeR)
library(limma)


min_reads_per_cell       <- 200
min_cells_per_fovcluster <- 20
min_samples_to_calc      <- 2 # require 2 samples on on either side of contrast


# Remove cells with too few counts
so <- so[,so$nCount_RNA >= min_reads_per_cell]


# Define fov+cluster groups, with all relevant sample annotation
# remove those with too few cells.
so$fov_cluster <- paste0(so$fov_name,"_", so$celltype_subset)
celltype_summary_table <- so@meta.data %>% 
  group_by(condition, group, individual_code, fov_name, celltype_subset, fov_cluster) %>%
  summarise(cells=n(), .groups = 'drop')


# Calculate pseudobulk for each fov+cluster group
pseudobulk_counts <- PseudobulkExpression(so, assays = "RNA", layer="counts",  method = 'aggregate', group.by = 'fov_cluster')
pseudobulk_counts_matrix <- pseudobulk_counts[["RNA"]]
# Change - back to _. Ideally have neither and skip this step
colnames(pseudobulk_counts_matrix)<-gsub("-","_",colnames(pseudobulk_counts_matrix))


# Determin fov_clusters with eough cells
# Filter both pseudobulk matrix and pseudobulk annotation 
passed_fov_clusters <- celltype_summary_table$fov_cluster[celltype_summary_table$cells >= min_cells_per_fovcluster]
pseudobulk_counts_matrix <- pseudobulk_counts_matrix[,passed_fov_clusters]
pseudobulk_anno_table    <- celltype_summary_table[passed_fov_clusters,]


# Calculate DE across every celltype
de_result_list <- list()

for (the_celltype in levels(so$celltype_subset)) {
  
  anno_table.this   <- pseudobulk_anno_table[pseudobulk_anno_table$celltype_subset == the_celltype,]
  count_matrix.this <- pseudobulk_counts_matrix[,anno_table.this$fov_cluster]
 
  print(the_celltype)
  
  # skip clusters with nothing 
  if( nrow(anno_table.this) < 1 ) {next}
  
  # Setup objects for limma
  dge <- DGEList(count_matrix.this)
  dge <- calcNormFactors(dge)
  
  # Build model
  group           <- anno_table.this$group
  individual_code <- anno_table.this$individual_code

  # To do any calculations, we need at least 2 pseudobulk groups per contrast.
  # there are plenty in this experiemnt, but with less replicates and rare cell types
  # it may be neccesary to check and skip certain contrasts

  # Model design 
  design    <- model.matrix( ~0 + group)

  vm  <- voom(dge, design = design, plot = FALSE)
  
  # Adding dupliate correlation to use individual fovs, rather than pooled per biosample
  corrfit <- duplicateCorrelation(vm, design, block=individual_code)
  fit     <- lmFit(vm, design, correlation = corrfit$consensus, block=individual_code) 

  # Then fit contrasts and run ebayes
  contrasts <- makeContrasts(UCvHC  = groupUC - groupHC
                           levels=coef(fit))

  fit <- contrasts.fit(fit, contrasts)
  fit <- eBayes(fit)

  
  for ( the_coef in colnames(contrasts) ) {
    de_result.this <- topTable(fit, n = Inf, adjust.method = "BH", coef = the_coef) %>%
      rownames_to_column("target") %>%
      mutate(contrast=the_coef,
             celltype=the_celltype) %>%
      select(celltype,contrast,target,everything()) %>%
      arrange(P.Value)
    
    
      de_result_list[[paste(the_celltype, the_coef, sep="_")]] <- de_result.this
    
  }

}

de_results_all <- bind_rows(de_result_list)
de_results_sig <- filter(de_results_all, adj.P.Val < 0.01)


```


# Results

```{r}
DT::datatable(head(de_results_all))
```

This table is the typical output of _limma_ tests; With a couple of extra columns added by our code.

* **celltype**: The celltype being tested (Added by example code)
* **contrast**: The contrast being tested (Added by example code)
* **target** : The gene name (Added by example code, is the rowname in limma output)
* **rownames** : The tested cell types
* **logFC** : Log 2 fold change between tested groups. For a test of Test-Con; 
    + At logFC +1, A is doubled B. 
    + At logFC -1, A is half of B.  
    + A logFC 0 indicates no change.
* **AveExpr** : Average expression of a gene across all replicates. 
* **t** : Moderated T-statistic. See Limma documentation.
* **P.Value** : P.value
* **adj.P.Val** : A multiple-hypothesis corrected p-value
* **B** : B statistic (rarely used). See Limma documentation.


# More Information


Todo
